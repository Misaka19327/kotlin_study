# 2.1.0 Modifier修饰符

（使用 ModifierTest 项目）

在传统开发中，Android 通常使用 XML 文件来描述组件的样式，而在 Jetpack Compose 中一般使用 Modifier来为组件应用一系列的样式设置，如边距，字体，位移等。相应的，在每个 Composable 中，都有一个 modifier 参数，通过传入自定义的 Modifier 来修改组件的样式。

##### 1 常用修饰符

首先是一些通用的 Modifier 修饰符。

###### 1 Modifier.size

首先是最常用的 size 修饰符，它一般被用于设置被修饰组件的大小。示例如下：

```kotlin
@Composable
fun ShowPicture() {
    Row {
       Image(
           painterResource(id = R.drawable.pic1),
           modifier = Modifier
               .size(60.dp) // width和height同时设置为60dp
               .clip(CircleShape), // 将图片裁剪为圆形
           contentDescription = null
       )
    }
    Spacer(modifier = Modifier.width(10.dp))
    Image(
        painterResource(id = R.drawable.pic1),
        contentDescription = null,
        modifier = Modifier
            .size(100.dp)
            .clip(CircleShape)
    )
}
```

size 同时还有个重载方法，支持单独设置组件的宽高：

```kotlin
@Composable
fun ShowPicture() {
    Row {
    Image(
        painterResource(id = R.drawable.pic2),
        contentDescription = null,
        modifier = Modifier
            .size(
                width = 200.dp, height = 500.dp
                // 分别指定组件宽度和高度
            )
            .clip(CircleShape)
    )
}
```

###### 2 Modifier.background

background 修饰符用于为被修饰组件添加背景色。它支持设置 color 的纯色背景，也可以使用 brush 设置渐变色背景。Brush 是 Compose 提供的用来创建线性渐变色的工具。示例如下：

```kotlin
@Composable
@Preview
fun showBackground() {
    // 创建 Brush 渐变色
    val verticalGradientBrush = Brush.verticalGradient(
        colors = listOf(
            Color.Red,
            Color.Yellow,
            Color.White
        )
    )
    Row{
        Box(
            Modifier
                .size(50.dp)
                .background(color = Color.Red) // 设置纯色背景
        ) {
            Text("纯色", Modifier.align(Alignment.Center))
        }
        Spacer(Modifier.size(10.dp))
        Box(
            Modifier
                .size(50.dp)
                .background(brush = verticalGradientBrush) // 设置渐变色背景
        ) {
            Text(text = "渐变色", Modifier.align(Alignment.Center))
        }
    }
}
```

实际效果：

![1675160810788](image/2.1.0Modifier修饰符/1675160810788.png)

另外，传统View视图中的 background 属性可以为图片设定背景，而在 Compose 中，这个 background只能设定颜色背景。如果需要为图片设定背景需要使用 Box 布局配合 Image 实现。

###### 3 Modifier.fillMaxSize

这个和前面的 size 有点像，但是这个会默认在某个维度上直接填满父空间。示例如下：

```kotlin
// 填满整个父空间
Box(Modifier.fillMaxSize() .background(Color.Red))
// 在高度上填满父空间
Box(Modifier.fillMaxHeight() .background(Color.Red))
// 在宽度上填满父空间
Box(Modifier.fillMaxWidth() .background(Color.Red))
```

###### 4 Modifier.border ，Modifier.padding

border 一般用来为被修饰组件添加边框。这个边框可以指定颜色，粗细和形状。而 padding 一般被用来为被修饰组件增加间隙。可以在 border 的前后各插入一个 padding，区分对外和对内的间隙。相较于传统 View 视图有 Margin 和 Padding 之分，Compose 中只有 padding 这一种修饰符，根据不同情况和不同的位置发挥不同作用，概念更加简洁。

示例如下：

```kotlin
@Composable
@Preview
fun ShowBorder() {
    Box(modifier = Modifier
        .padding(8.dp)
        .border(2.dp, Color.Red, shape = RoundedCornerShape(2.dp))
        .padding(8.dp)
    ) {
        Spacer(modifier = Modifier
            .size(width = 100.dp, height = 10.dp)
            .background(Color.Red)
        )
    }
}
```

效果：

![1675165517900](image/2.1.0Modifier修饰符/1675165517900.png)

###### 5 Modifier.offset

offset修饰符用于移动被修饰组件的位置，一般在使用是只分别传入水平方向和垂直方向的偏移量即可。由于Modifier的调用顺序会影响最终UI呈现的效果，所以在示例中先使用offset修饰符，然后再使用background修饰符上背景色。

示例如下：

```kotlin
@Composable
@Preview
fun ShowOffset() {
    Box(modifier = Modifier
        .size(300.dp)
        .background(Color.Red)
    ){
        Spacer(modifier = Modifier
            .size(width = 100.dp, height = 10.dp)
            .offset(x = 200.dp, y = 150.dp)
            .background(Color.Green)
        )
    }
}
```

效果：

![1675167992228](image/2.1.0Modifier修饰符/1675167992228.png)

##### 2 作用域限定Modifier修饰符

Compose支持让某些Modifier修饰符只能在特定作用域内发挥作用，有利于类型安全地引用它们。

作用域，在kotlin中指的是带有Receiver的代码块。例如Box组件的参数content就是一个Receiver类型为BoxScope的代码块：

![1675303398591](image/2.1.0Modifier修饰符/1675303398591.png)

Receiver类型，默认可以跨层级访问。示例如下：

```kotlin
class AScope {
    fun visitA() {}
}
class BScope {
    fun visitB() {}
}
fun funA(scope: AScope.() -> Unit) {
    scope(AScope())
}
fun funB(scope: BScope.() -> Unit) {
    scope(BScope())
}
fun main() {
    funA { 
        funB { 
            visitA()
        }
    }
}
```

在这段代码里，由于funB{}处于funA{}的内部，所以可以在funB{}中访问到属于funA{}的方法visitA()。

而在Compose的语法结构里，一般只需要调用当前作用域的方法，而像这段示例代码里这样跨级访问会加大报错的概率。在Compose中为了解决这个问题，可以使用@LayoutScopeMarker注解来规避Receiver的跨级访问。而Compose的常用组件都已经使用了这个注解。对于添加了这个注解的Receiver，其作用域中默认只能调用作用域提供的方法。如果要跨级调用外层作用域的方法，必须

![1675304927694](image/2.1.0Modifier修饰符/1675304927694.png)
