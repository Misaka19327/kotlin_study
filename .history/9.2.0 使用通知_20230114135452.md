# 9.2.0 使用通知

（使用NotificationTest项目）

##### 1 创建通知渠道

通知这个功能，初衷是好的，但是逐渐被开发者们玩坏了，这也就是“通知渠道”的来源。起初Android的通知，用户只能设定接收或者完全不接收某个应用的通知。一旦开发者开发的应用，以吸引用户打开的目的向用户大量推送通知，而用户想要屏蔽一部分消息的同时，还想要接收部分关键信息的时候，最初的通知系统就不够用了。

于是，Android 8.0 引入了通知渠道的概念。简而言之，就是为自己应用的通知划分大类（即渠道），每个应用都有创建任意大类的自由，但决定这些大类的通知是否出现，是否响铃，是否震动，是交给用户去控制的。而且这些渠道一旦创建就不能再修改，所以渠道的划分是需要好好考虑的。

建立通知渠道的步骤如下：首先，需要一个NotificationManager对象对通知进行管理，这个对象可以通过调用Context的getSystemService()方法获取，这个方法需要传入一个字符串参数用于确定获取系统的哪个服务，这里需要传入Context.NOTIFICATION_SERVICE。之后，要使用NotificationChannel类构建一个通知渠道，并且调用NotificationManager对象的createNotificationChannel()方法完成创建，因为这个类和这个方法都是Android 8.0 中新增的API，因此使用的时候还得判断版本才可以：

```kotlin
val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(channelId, channelName, importace)
            manager.createNotificationChannel(channel)
        }
```

创建一个通知渠道，至少需要渠道ID、渠道名称和重要等级这3个参数，其中渠道ID只需要保证是全局唯一就可以。渠道名称是给用户看的。重要等级主要有IMPORTANCE_HIGH，IMPORTANCE_LOW，IMPORTANCE_MIN三种，对应高中低。当然这只是初始状态下的重要等级，用户在使用应用的时候可以随意更改通知的重要等级。

##### 2 通知的基本用法

通知相对会灵活一些，它可以在Activity里创建，也可以在BroadcastReceiver里创建，还能在Service里创建，不论在哪里创建，创建的步骤都是相同的。

首先，需要用一个Builder构造器来创建Notification对象。这个构造器最好是用 AndroidX 库中的，原因就是 Android 系统的每个版本都会对通知做出或多或少的更改，因此如果 API 不稳定的话会严重影响通知的工作。调用 AndroidX 库中的 NotificationCompat 构造器能够避免这个问题，使得通知能在每个版本上都能正常工作。这个构造器的构造函数接收两个参数：第一个参数是context，第二个参数是渠道 ID ，需要和之前建立的渠道的 ID 相对应：

```kotlin
val notification = NotificationCompat.Builder(context, channelId).build()
```

当然，上面只是一个空的Notification对象，啥都没有。在最终的build()方法之前，可以加任意多的set方法来丰富这个Notification对象，比如这样：

```kotlin
val notification = NotificationCompat.Builder(context, channelId)
            .setContentTitle("This is content title.")
            .setContentText("This is content text")
            .setSmallIcon(R.drawable.smallIcon)
            .setLargeIcon(R.drawable.largeIcon)
            .build()
```

四个方法都很一目了然，就是最后两个设置图标的，只能使用纯alpha图层的图片进行设置。

最后，调用NotificationManager的notify()方法就可以发送通知了。这个方法接收两个参数，一个是id，要保证每个通知指定的id都是不同的；第二个参数是Notification对象。显示一个通知示例如下：

```kotlin
manager.notify(1, notification)
```

一个完整的设置通知的过程就结束了。这个过程体现在实际项目上大概就是这样：

首先，先给activity_main.xml里加个按钮，用于发送通知。之后，修改MainActivity：

```kotlin
class MainActivity : AppCompatActivity() {
    lateinit var binding : ActivityMainBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel("normal", "Normal", NotificationManager.IMPORTANCE_DEFAULT)
            manager.createNotificationChannel(channel)
        }
        binding.sendNotification.setOnClickListener {
            val notification = NotificationCompat.Builder(this, "normal")
                .setContentTitle("This is content title")
                .setContentText("This is content text")
                .setSmallIcon(R.drawable.small_icon)
                .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.small_icon))
                .build()
            manager.notify(1, notification)
        }
    }
}
```

写法和之前的示例大差不差，需要说明的点如下：首先，这个获取NotificationManager实例并且创建通知渠道的过程，只会执行一次。等到第二次打开这个Activity执行onCreate()的时候，系统会检测到渠道已经存在了，因此不会重复创建。其次，如果向NotificationCompat.Builder的构造函数里传不存在的通知渠道的话，通知是无法显示的。最终效果如下：

![1673619104603](image/9.2.0使用通知/1673619104603.png)

除了创建和发送通知，通知还有一个重要的功能，就是点击进入应用，这部分要借助PendingIntent。它和Intent一样，能够打开Activity，能够启动Service或者发送广播什么的。但是PendingIntent相较于Intent的立即启动，它倾向于在某个合适的时机执行某个动作，因此PendingIntent也可以简单的理解为延迟启动的Intent。

PendingIntent提供了几个静态方法用于获取PendingIntent的实例，可以根据需求来选择来用getActivity()，getBroadcast()还是getService()。这几个方法接收的参数都是相同的：第一个是Context；第二个参数一般用不到直接传0就行；第三个参数是一个Intent对象，通过这个Intent对象就可以构造出这个PendingIntent的意图；第四个参数用于确定PendingIntent的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT、FLAG_UPDATE_CURRENT这四种，大多数情况还是用不着直接传0就行。

说完了PendingIntent，再说它要怎么和通知连起来。NotificationCompat.Builder这个构造器还能连一个setContentIntent()方法，接收一个PendingIntent对象参数。

现在，先准备好另一个Activity，以便待会启动，它的布局文件：

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >
  
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:textSize="24sp"
        android:text="This is notification layout."
        />
</RelativeLayout>
```

之后修改MainActivity中的代码：

```kotlin
binding.sendNotification.setOnClickListener {
            val intent = Intent(this, NotificationActivity::class.java)
            val pi = PendingIntent.getActivity(this, 0, intent, 0)
            val notification = NotificationCompat.Builder(this, "normal")
                .setContentTitle("This is content title")
                .setContentText("This is content text")
                .setSmallIcon(R.drawable.small_icon)
                .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.small_icon))
                .setContentIntent(pi)
                .build()
            manager.notify(1, notification)
        }
```

最后，通知是不会自动取消的，点击了之后它还会在通知栏呆着。这种情况有两个方法：第一个是在NotificationCompat.Builder里再加一个setAutoCancel()：

```kotlin
binding.sendNotification.setOnClickListener {
            val intent = Intent(this, NotificationActivity::class.java)
            val pi = PendingIntent.getActivity(this, 0, intent, 0)
            val notification = NotificationCompat.Builder(this, "normal")
                .setContentTitle("This is content title")
                .setContentText("This is content text")
                .setSmallIcon(R.drawable.small_icon)
                .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.small_icon))
                .setContentIntent(pi)
		.setAutoCancel(true)
                .build()
            manager.notify(1, notification)
        }
```

另一个方法是显式调用NotificationManager的cancel()方法将其取消，它接收一个参数，就是通知指定的那个id：

```kotlin
val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
manager.cancel(1)
```

最后效果：

![1673622556926](image/9.2.0使用通知/1673622556926.png)

还有一个要提的点就是：

![1673622695863](image/9.2.0使用通知/1673622695863.png)

---

很明显，Android 12 又改了机制，要求创建PandingIntent的时候那个flag必须传一个参数，要么是FLAG_IMMUTABLE，要么是FLAG_MUTABLE，否则当触发这个PandingIntent时就会报错。

FLAG_IMMUTABLE：表示PendingIntent中的Intent不能被将Intent传递给PendingIntent.send()的其他应用程序修改。应用总是可以使用FLAG_UPDATE_CURRENT来修改它自己的PendingIntent在Android 12之前，默认情况下，不带此标志创建的PendingIntent是可变的。在Android 6 (API 23) 之前的Android版本上，PendingIntent总是可变的。

FLAG_MUTABLE：表示PendingIntent中的Intent应允许应用程序通过合并PendingIntent.send()的Intent参数值来更新其内容。
始终填写任何可变的PendingIntent的包装Intent的ComponentName。不这样做可能会导致安全漏洞！
此标志是在Android 12中添加的。在Android 12之前，在没有FLAG_IMMUTABLE标志的情况下创建的任何PendingIntent都是隐式可变的。

---

##### 3 通知的进阶技巧

之前建立的是最基础的通知，实际上那属于最基本的通知类型。NotificationCompat.Builder中有非常丰富的API可以使用，从而创建更加多样的通知效果。

首先是setStyle()，它允许在通知里构建富文本的通知内容（可以加除了文字和图片之外的东西），它接受一个NotificationCompat.Style参数，这个参数就是用来构建富文本的。比如这样：

![1673675477877](image/9.2.0使用通知/1673675477877.png)

它可以允许通知显示很长一段文字而不被折叠，效果如下：

![1673675687226](image/9.2.0使用通知/1673675687226.png)
