# 10.4.0 Service的更多技巧

（使用ServiceTest）

##### 1 使用前台Service

在10.3.2里曾经说到过，前台Service能保证自己不会被系统回收。它和普通的Service的最大不同，就是它有个前台无法取消的状态栏显示，形似通知。正是因为它无法取消，所以系统不太倾向于回收它，也因为它必须在通知栏显示，也避免了某些恶意应用在后台大量占用手机资源的情况。

创建前台Service，修改MyService如下：

```kotlin
// 实际只修改了onCreate()的代码
override fun onCreate() {
        super.onCreate()
        Toast.makeText(this, "onCreate executed", Toast.LENGTH_SHORT).show()

        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel("my_service", "前台Service通知", NotificationManager.IMPORTANCE_DEFAULT)
            manager.createNotificationChannel(channel)
        }
        val intent = Intent(this, MainActivity::class.java)
        val pi = PendingIntent.getActivity(this, 0, intent, 0)
        val notification = NotificationCompat.Builder(this, "my_service")
            .setContentTitle("This is content title")
            .setContentText("This is content text.")
            .setSmallIcon(R.drawable.small_icon)
            .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.big_picture))
            .build()
        startForeground(1, notification)
    }
```

修改AndroidManifest如下（从Android 9.0 开始，使用前台Service必须声明权限）：

```xml
位置在manifest标签和application标签之间
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
```

以上的修改，大部分都直接使用了创建通知的代码。只是这次构建了Notificaiton对象之后，并没有调用NotificationManager将其显示出来，而是调用startForeground()方法。它接收两个参数：一个是通知的id，类似于notify()方法的第一个参数；另一个是之前构建的Notification对象。

效果如下：

![1674057999725](image/10.4.0Service的更多技巧/1674057999725.png)

##### 2 使用IntentService

因为Service的代码，默认情况下都是运行在主线程中的。这种情况下，一些耗时的逻辑就需要开启一个子线程：

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        thread {
		// 处理具体的耗时的逻辑
	}
        return super.onStartCommand(intent, flags, startId)
    }
```

但是这样的话，Service就会一直处于运行状态，必须调用stopService()或者stopSelf()方法，或者被系统回收Service才会停止。所以正常情况下，上面的代码还得加一行：

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        thread {
		// 处理具体的耗时的逻辑
		stopSelf()
	}
        return super.onStartCommand(intent, flags, startId)
    }
```

IntentService，就可以看作是上面那个Service的封装。新建一个MyIntentService类继承自IntentService：

![1674134309686](image/10.4.0Service的更多技巧/1674134309686.png)

（其实这里有模板，虽然这个模板我也没看懂）

```kotlin
class MyIntentService : IntentService("MyIntentService") {

    override fun onHandleIntent(intent: Intent?) {
        Log.d("MyIntentService", "Thread id is ${Thread.currentThread().name}")
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d("MyIntentService", "onDestroy executed.")
    }
}
```

然后再给activity_main.xml加一个
