# 10.2.0 Android多线程编程

##### 1 Service

Service是Android里实现程序后台运行的解决方案。它可以执行一些不依赖任何用户界面，不需要和用户交互，但是还得长期运行的任务。不过需要注意的是，虽然看着像是后台，但是Service并不运行在一个独立的进程之中，而是依赖于创建Service时所在的应用程序的进程。当这个进程被结束时，Service也会结束。

还有，Service并不会自动开启线程，所有的代码都会跑在主线程里。因此在Service里得手动创建子线程，否则很容易出现主线程被阻塞的情况。

##### 2 线程的基本用法

线程，在官方文档里是这么写的：

> 启动应用时，系统会为该应用创建一个称为“main”（主线程）的执行线程。此线程非常重要，因为其负责将事件分派给相应的界面微件，其中包括绘图事件。此外，应用与 Android 界面工具包组件 `android.widget`和 `android.view`软件包的组件）也几乎都在该线程中进行交互。因此，主线程有时也称为界面线程。但在一些特殊情况下，应用的主线程可能并非其界面线程。

根据这段文字可以得知，很多情况下不要将处理数据的任务放进主线程里。比如说要从网上请求某个数据，有时候可能服务器出了问题一时半会请求不下来，如果这个任务在主线程里就会将其阻塞，从而影响用户的使用的体验。

申请线程大概有这么四种方式：

```kotlin
// 新建类继承自Thread类，重写父类的run()方法，再创建这个类的实例并调用它的start()方法
class MyThread : Thread() {
	override fun run() {
		// 编写具体逻辑
	}
}
MyThread.start()
```

```kotlin
/* 
实现Runnable接口来定义一个线程
启动这个线程就是构造一个Thread对象，并且把实现了Runnable接口的对象传进前者的构造函数里，再调用它的start()方法
*/
class MyThread : Runnable {
	override fun run(){
		//编写具体逻辑
	}
}
val myThread = MyThread()
Thread(myThread).start()
```

```kotlin
// 这是第二种方法的变种，直接用Lambda的方式创建Thread类
Thread {
    // 编写具体逻辑
}.start()
```

```kotlin
// 这是kotlin所有独有的，thread()是kotlin内置的顶层函数，直接写逻辑就行，不用start()
thread {
    // 编写具体逻辑
}
```

##### 3 在子线程中更新UI

首先，Android的UI是线程不安全的。这句话的意思就是，Android不允许在除了主线程以外的其他线程里操作应用程序的UI元素，否则一定会出现异常。但是这比较反直觉，之前说过启动线程就是为了避免操作数据带来的延误时间从而导致主线程被阻塞的问题。但是有的控件可能就是为了显示被操作的数据而存在的，比如说在子线程里下载一个图片，然后让它在页面上显示出来，这个“线程不安全”就无法在子线程里直接操作这个显示图片的控件。

为了解决这个问题，Android提供了一套异步消息处理机制，专门用于处理在子线程里操作UI的问题：
